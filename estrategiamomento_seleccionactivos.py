# -*- coding: utf-8 -*-
"""EstrategiaMomento.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16uDw1ZXGjwvTFpkdLL5cRYBfYLOaA8NA
"""


## SELECCION MENSUAL ACTIVOS POR MOMENTUM+CORRELATION+VOLATILIDAD
# 1. Importar Librerías
import pandas as pd
import sqlite3
from sqlite3 import Error
import numpy as np
from datetime import datetime
from dateutil.relativedelta import relativedelta
from scipy.stats import pearsonr

# 2. Crear Conexión a la Base de Datos
def crear_conexion(db_file):
    conn = None
    try:
        conn = sqlite3.connect(db_file)
        print(f"Conexión establecida a {db_file}")
        return conn
    except Error as e:
        print(f"Error al conectar a la base de datos: {e}")
    return conn

# 3. Obtener Lista de Activos
def obtener_activos(db_file):
    conn = crear_conexion(db_file)
    if conn is None:
        return []
    try:
        c = conn.cursor()
        c.execute("SELECT name FROM sqlite_master WHERE type='table'")
        activos = [row[0] for row in c.fetchall()]
        conn.close()
        print(f"Activos encontrados: {activos}")
        return activos
    except sqlite3.Error as e:
        print(f"Error al obtener activos: {e}")
        conn.close()
        return []

# 4. Leer Datos de un Activo
def leer_datos_activo(db_file, activo, fecha_inicio, fecha_fin):
    conn = crear_conexion(db_file)
    if conn is None:
        return None
    try:
        query = f"""
            SELECT date, adj_close AS Adj_Close
            FROM {activo}
            WHERE date BETWEEN ? AND ?
            ORDER BY date
        """
        df = pd.read_sql_query(query, conn, params=(fecha_inicio, fecha_fin), parse_dates=['date'])
        df.set_index('date', inplace=True)
        print(f"Datos leídos para {activo} desde {fecha_inicio} hasta {fecha_fin}: {len(df)} filas")
        conn.close()
        return df
    except sqlite3.Error as e:
        print(f"Error al leer datos de {activo}: {e}")
        conn.close()
        return None

# 5. Calcular Momentum Score
def calcular_momentum(df, activo):
    try:
        if len(df) < 13:
            print(f"No hay suficientes datos para {activo}: {len(df)} filas disponibles")
            return None

        p0 = df['Adj_Close'].iloc[-1]  # Mes actual
        p1 = df['Adj_Close'].iloc[-2]  # 1 mes atrás
        p3 = df['Adj_Close'].iloc[-4]  # 3 meses atrás
        p6 = df['Adj_Close'].iloc[-7]  # 6 meses atrás
        p12 = df['Adj_Close'].iloc[-13] # 12 meses atrás

        momentum_score = (
            12 * (p0 / p1) +
            4 * (p0 / p3) +
            2 * (p0 / p6) +
            (p0 / p12) -
            19
        )

        return {'activo': activo, 'momentum_score': momentum_score}
    except Exception as e:
        print(f"Error al calcular momentum para {activo}: {e}")
        return None

# 6. Calcular Volatilidades
def calcular_volatilidad(df, activo, meses):
    try:
        if len(df) < meses:
            print(f"No hay suficientes datos para calcular volatilidad de {meses} meses para {activo}: {len(df)} filas")
            return None

        # Calcular retornos mensuales
        retornos = df['Adj_Close'].pct_change().dropna()
        # Tomar los últimos 'meses' retornos
        retornos = retornos.iloc[-meses:]
        # Calcular desviación estándar
        volatilidad = retornos.std()
        return volatilidad
    except Exception as e:
        print(f"Error al calcular volatilidad para {activo}: {e}")
        return None

# 7. Calcular Matriz de Correlación
def calcular_correlaciones(datos_activos, activos):
    try:
        # Crear DataFrame con retornos mensuales
        retornos = pd.DataFrame()
        for activo in activos:
            df = datos_activos[activo]
            if df is not None and len(df) >= 12:
                retornos[activo] = df['Adj_Close'].pct_change().dropna()

        if retornos.empty:
            print("No hay datos suficientes para calcular correlaciones")
            return None

        # Calcular matriz de correlación
        matriz_correlacion = retornos.corr(method='pearson')
        print("\nMatriz de correlación:\n", matriz_correlacion)
        return matriz_correlacion
    except Exception as e:
        print(f"Error al calcular correlaciones: {e}")
        return None

# 8. Seleccionar Activos
def seleccionar_activos(db_file, fecha_fin):
    # Calcular fechas
    fecha_inicio_12m = (fecha_fin - relativedelta(months=13)).strftime('%Y-%m-%d')
    fecha_inicio_4m = (fecha_fin - relativedelta(months=4)).strftime('%Y-%m-%d')
    fecha_fin_str = fecha_fin.strftime('%Y-%m-%d')

    # Obtener lista de activos
    activos = obtener_activos(db_file)
    if not activos:
        print("No se encontraron activos en la base de datos")
        return None

    # Leer datos y calcular indicadores
    datos_activos = {}
    momentum_results = []
    volatilidades = []

    for activo in activos:
        print(f"\nProcesando {activo} para {fecha_fin_str}...")
        # Leer datos para 12 meses (momentum y correlaciones)
        df_12m = leer_datos_activo(db_file, activo, fecha_inicio_12m, fecha_fin_str)
        # Leer datos para 4 meses (volatilidad corta)
        df_4m = leer_datos_activo(db_file, activo, fecha_inicio_4m, fecha_fin_str)

        if df_12m is None or df_4m is None or df_12m.empty or df_4m.empty:
            print(f"No se pudieron obtener datos para {activo}")
            continue

        datos_activos[activo] = df_12m

        # Calcular volatilidades
        vol_corta = calcular_volatilidad(df_4m, activo, 4)
        vol_larga = calcular_volatilidad(df_12m, activo, 12)

        if vol_corta is None or vol_larga is None:
            print(f"No se pudo calcular volatilidad para {activo}")
            continue

        volatilidades.append({
            'activo': activo,
            'vol_corta': vol_corta,
            'vol_larga': vol_larga
        })

        # Calcular momentum
        momentum_data = calcular_momentum(df_12m, activo)
        if momentum_data:
            momentum_results.append(momentum_data)

    if not momentum_results:
        print("No hay datos de momentum disponibles")
        return None

    # Filtrar por volatilidad (corta <= larga)
    df_volatilidades = pd.DataFrame(volatilidades)
    df_volatilidades = df_volatilidades[df_volatilidades['vol_corta'] <= df_volatilidades['vol_larga']]
    activos_validos = df_volatilidades['activo'].tolist()
    print(f"\nActivos con volatilidad corta <= larga: {activos_validos}")

    # Filtrar momentum por activos válidos
    df_momentum = pd.DataFrame(momentum_results)
    df_momentum = df_momentum[df_momentum['activo'].isin(activos_validos)]

    # Filtrar por momentum score (0 <= score <= 3)
    df_momentum = df_momentum[(df_momentum['momentum_score'] >= 0.7) & (df_momentum['momentum_score'] <= 3)]
    print("\nMomentum filtrado (0.7 <= score <= 3):\n", df_momentum)

    if df_momentum.empty:
        print("No hay activos con momentum score entre 0 y 3. No se seleccionan activos.")
        return pd.DataFrame({'fecha': [fecha_fin_str], 'activos_seleccionados': [[]]})

    # Ordenar por momentum
    df_momentum = df_momentum.sort_values(by='momentum_score', ascending=False)

    # Calcular correlaciones
    matriz_correlacion = calcular_correlaciones(datos_activos, activos_validos)
    if matriz_correlacion is None:
        print("No se pudo calcular la matriz de correlación. Seleccionando solo por momentum.")
        seleccionados = df_momentum.head(3)[['activo']]
        seleccionados['fecha'] = fecha_fin_str
        return seleccionados

    # Seleccionar activos
    seleccionados = []
    activos_restantes = df_momentum['activo'].tolist()

    # Seleccionar el primero (mayor momentum)
    if activos_restantes:
        primer_activo = df_momentum.iloc[0]['activo']
        seleccionados.append(primer_activo)
        activos_restantes.remove(primer_activo)
        print(f"Primer activo seleccionado: {primer_activo}")

    # Seleccionar hasta 2 más, minimizando correlación promedio
    while len(seleccionados) < 3 and activos_restantes:
        mejor_activo = None
        menor_correlacion_promedio = float('inf')

        for candidato in activos_restantes:
            if candidato in matriz_correlacion.columns:
                correlaciones = [matriz_correlacion.loc[candidato, seleccionado] for seleccionado in seleccionados if seleccionado in matriz_correlacion.index]
                if correlaciones:
                    correlacion_promedio = np.mean(correlaciones)
                    if correlacion_promedio < menor_correlacion_promedio:
                        menor_correlacion_promedio = correlacion_promedio
                        mejor_activo = candidato

        if mejor_activo:
            seleccionados.append(mejor_activo)
            activos_restantes.remove(mejor_activo)
            print(f"Activo seleccionado: {mejor_activo} (correlación promedio: {menor_correlacion_promedio:.3f})")
        else:
            break

    # Preparar resultado
    resultado = pd.DataFrame({
        'fecha': [fecha_fin_str],
        'activos_seleccionados': [seleccionados]
    })
    print(f"\nActivos seleccionados para {fecha_fin_str}: {seleccionados}")
    return resultado

# 9. Main
def main():
    # Configuración
    db_file = 'precios_activos_mensual.db'
    # Último día del mes completo más reciente
    hoy = datetime.today()
    fecha_fin = (hoy.replace(day=1) - timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
    fecha_fin_str = fecha_fin.strftime('%Y-%m-%d')

    print(f"Ejecutando estrategia para {fecha_fin_str}...")

    # Seleccionar activos
    seleccionados = seleccionar_activos(db_file, fecha_fin)

    if seleccionados is not None:
        # Guardar resultados
        output_file = 'seleccion_momentum_mensual.csv'
        seleccionados.to_csv(output_file, index=False)
        print(f"\nResultados guardados en '{output_file}'")
    else:
        print("No se generaron selecciones")

if __name__ == '__main__':
    main()